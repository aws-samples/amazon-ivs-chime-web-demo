const AWS = require('aws-sdk');
const ddb = new AWS.DynamoDB();
const { CONNECTIONS_TABLE_NAME, MEETINGS_TABLE_NAME, ATTENDEES_TABLE_NAME } = process.env;
const chime = new AWS.Chime({ region: 'us-east-1' }); // Must be in us-east-1
chime.endpoint = new AWS.Endpoint('https://service.chime.aws.amazon.com/console');

const oneDayFromNow = Math.floor(Date.now() / 1000) + 60 * 60 * 24;
const strictVerify = true;

const response = {
  "statusCode": 200,
  "headers": {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Methods": "OPTIONS,GET,PUT,POST",
    "Content-Type": "application/json"
  },
  "body": '',
  "isBase64Encoded": false
};

function uuid() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

const getMeeting = async(meetingTitle) => {
  const filter = {
    TableName: MEETINGS_TABLE_NAME,
    Key: {
      'Title': {
        S: meetingTitle
      },
    },
  };

  console.info("getMeeting > filter:", JSON.stringify(filter, null, 2));

  const result = await ddb.getItem(filter).promise();

  console.info("getMeeting > result:", JSON.stringify(result, null, 2));

  if (!result.Item) {
    return null;
  }
  const meetingData = JSON.parse(result.Item.Data.S);
  meetingData.PlaybackURL = result.Item.PlaybackURL.S;
  try {
    await chime.getMeeting({
      MeetingId: meetingData.Meeting.MeetingId
    }).promise();
  } catch (err) {
    console.info("getMeeting > try/catch:", JSON.stringify(err, null, 2));
    return null;
  }
  return meetingData;
};

const putMeeting = async(title, playbackURL, meetingInfo) => {
  await ddb.putItem({
    TableName: MEETINGS_TABLE_NAME,
    Item: {
      'Title': { S: title },
      'PlaybackURL': { S: playbackURL },
      'Data': { S: JSON.stringify(meetingInfo) },
      'TTL': {
        N: '' + oneDayFromNow
      }
    }
  }).promise();
};

const endMeeting = async(title) => {
  const meetingInfo = await getMeeting(title);

  try {
    await chime.deleteMeeting({
      MeetingId: meetingInfo.Meeting.MeetingId,
    }).promise();
  } catch (err) {
    console.info("endMeeting > try/catch:", JSON.stringify(err, null, 2));
    // return null;
  }

  const params = {
    TableName: MEETINGS_TABLE_NAME,
    Key: {
      'Title': {
        S: title
      },
    },
  };

  console.info("deleteMeeting > params:", JSON.stringify(params, null, 2));

  const result = await ddb.delete(params).promise();

  console.info("deleteMeeting > result:", JSON.stringify(result, null, 2));

  return result;
};

const getAttendee = async(title, attendeeId) => {
  const result = await ddb.getItem({
    TableName: ATTENDEES_TABLE_NAME,
    Key: {
      'AttendeeId': {
        S: `${title}/${attendeeId}`
      }
    }
  }).promise();
  if (!result.Item) {
    return 'Unknown';
  }
  return result.Item.Name.S;
};

const getAttendees = async(title) => {
  const filter = {
    TableName: ATTENDEES_TABLE_NAME,
    FilterExpression: "begins_with(AttendeeId, :title)",
    ExpressionAttributeValues: {
      ":title": {
        "S": `${title}`
      }
    }
  };

  console.info("getAttendees > filter:", JSON.stringify(filter, null, 2));

  const result = await ddb.scan(filter).promise();

  console.info("getAttendees > result:", JSON.stringify(result, null, 2));

  if (!result.Items) {
    return 'Unknown';
  }

  let filteredItems = [];
  let prop
  for (prop in result.Items){
    filteredItems.push({
      AttendeeId: result.Items[prop].AttendeeId.S,
      Name: result.Items[prop].Name.S
    });
  }

  console.info("getAttendees > filteredItems:", JSON.stringify(filteredItems, null, 2));

  return filteredItems;
};

const putAttendee = async(title, attendeeId, name) => {
  await ddb.putItem({
    TableName: ATTENDEES_TABLE_NAME,
    Item: {
      'AttendeeId': {
        S: `${title}/${attendeeId}`
      },
      'Name': { S: name },
      'TTL': {
        N: '' + oneDayFromNow
      }
    }
  }).promise();
};

function simplifyTitle(title) {
  // Strip out most symbolic characters and whitespace and make case insensitive,
  // but preserve any Unicode characters outside of the ASCII range.
  return (title || '').replace(/[\s()!@#$%^&*`~_=+{}|\\;:'",.<>/?\[\]-]+/gu, '').toLowerCase() || null;
};